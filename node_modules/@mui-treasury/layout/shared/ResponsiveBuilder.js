"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResponsiveBuilder = void 0;

var _createSxResult = require("../utils/createSxResult");

var _muiBreakpoints = require("../utils/muiBreakpoints");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ResponsiveBuilder = /*#__PURE__*/function () {
  function ResponsiveBuilder(params) {
    _classCallCheck(this, ResponsiveBuilder);

    this.config = params.config;
    this.hidden = params.hidden;
    this.breakpointKeys = Object.keys(params.config);
  }

  _createClass(ResponsiveBuilder, [{
    key: "isHidden",
    value: function isHidden(breakpoint) {
      if (!this.hidden) return false;
      if (typeof this.hidden === "boolean" && this.hidden) return true;
      return this.hidden.includes(breakpoint);
    }
    /**
     * use target as base breakpoints, the result will start from the minimum of target
     *          xs | sm | md | lg | xl
     *  target     | y  |    |  y |
     *   this   y  |    | y  |    |
     *  ===============================
     *  result     | y  | y  | y  |
     */

  }, {
    key: "mergeBreakpoints",
    value: function mergeBreakpoints(target) {
      var targetFound = false;
      var result = [];
      var targetKeys = Array.isArray(target) ? target : Object.keys(target);
      var thisKeys = Object.keys(this.config);

      _muiBreakpoints.BREAKPOINT_KEYS.forEach(function (key) {
        if (targetKeys.includes(key)) {
          targetFound = true;
          result.push(key);
        } else {
          if (thisKeys.includes(key) && targetFound) {
            result.push(key);
          }
        }
      });

      return result;
    }
  }, {
    key: "generateSxWithHidden",
    value: function generateSxWithHidden(options) {
      var config = this.config,
          hidden = this.hidden;
      var hiddenValue = options.hiddenValue;

      if (hidden === true) {
        return hiddenValue !== undefined ? {
          xs: hiddenValue
        } : {};
      }

      var candidate;
      return (0, _createSxResult.createSxResult)(function (bp, lastResultVal) {
        var _config$bp;

        candidate = (_config$bp = config[bp]) !== null && _config$bp !== void 0 ? _config$bp : candidate;

        if (options.strict && lastResultVal === undefined && candidate === undefined) {
          // cannot find valid config and no result yet
          return hiddenValue;
        }

        if (candidate !== undefined) {
          var assignedValue = options.assignValue(candidate, bp, lastResultVal);
          var isHidden = Array.isArray(hidden) && hidden.includes(bp);
          return isHidden ? hiddenValue : assignedValue;
        }

        return undefined;
      });
    }
  }, {
    key: "generateSx",
    value: function generateSx(getValue, initialValue) {
      var _this = this;

      return (0, _createSxResult.createSxResult)(function (bp) {
        return getValue(_this.config[bp], bp);
      }, {
        breakpoints: this.breakpointKeys,
        initialValue: initialValue
      });
    }
  }, {
    key: "getSxDisplay",
    value: function getSxDisplay(appearance) {
      return this.generateSxWithHidden({
        assignValue: function assignValue() {
          return appearance;
        },
        hiddenValue: "none",
        strict: true
      });
    }
  }]);

  return ResponsiveBuilder;
}();

exports.ResponsiveBuilder = ResponsiveBuilder;