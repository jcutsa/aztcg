import { createSxResult } from "../utils/createSxResult";
import { BREAKPOINT_KEYS } from "../utils/muiBreakpoints";
export class ResponsiveBuilder {
  constructor(params) {
    this.config = params.config;
    this.hidden = params.hidden;
    this.breakpointKeys = Object.keys(params.config);
  }

  isHidden(breakpoint) {
    if (!this.hidden) return false;
    if (typeof this.hidden === "boolean" && this.hidden) return true;
    return this.hidden.includes(breakpoint);
  }
  /**
   * use target as base breakpoints, the result will start from the minimum of target
   *          xs | sm | md | lg | xl
   *  target     | y  |    |  y |
   *   this   y  |    | y  |    |
   *  ===============================
   *  result     | y  | y  | y  |
   */


  mergeBreakpoints(target) {
    var targetFound = false;
    var result = [];
    var targetKeys = Array.isArray(target) ? target : Object.keys(target);
    var thisKeys = Object.keys(this.config);
    BREAKPOINT_KEYS.forEach(key => {
      if (targetKeys.includes(key)) {
        targetFound = true;
        result.push(key);
      } else {
        if (thisKeys.includes(key) && targetFound) {
          result.push(key);
        }
      }
    });
    return result;
  }

  generateSxWithHidden(options) {
    var {
      config,
      hidden
    } = this;
    var hiddenValue = options.hiddenValue;

    if (hidden === true) {
      return hiddenValue !== undefined ? {
        xs: hiddenValue
      } : {};
    }

    var candidate;
    return createSxResult((bp, lastResultVal) => {
      var _config$bp;

      candidate = (_config$bp = config[bp]) !== null && _config$bp !== void 0 ? _config$bp : candidate;

      if (options.strict && lastResultVal === undefined && candidate === undefined) {
        // cannot find valid config and no result yet
        return hiddenValue;
      }

      if (candidate !== undefined) {
        var assignedValue = options.assignValue(candidate, bp, lastResultVal);
        var isHidden = Array.isArray(hidden) && hidden.includes(bp);
        return isHidden ? hiddenValue : assignedValue;
      }

      return undefined;
    });
  }

  generateSx(getValue, initialValue) {
    return createSxResult(bp => getValue(this.config[bp], bp), {
      breakpoints: this.breakpointKeys,
      initialValue
    });
  }

  getSxDisplay(appearance) {
    return this.generateSxWithHidden({
      assignValue: () => appearance,
      hiddenValue: "none",
      strict: true
    });
  }

}