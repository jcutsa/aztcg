function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { BREAKPOINT_KEYS } from "../utils/muiBreakpoints";
import { pickNearestBreakpoint } from "../utils/pickNearestBreakpoint";
import { StackedHeaders } from "./StackedHeaders";
export var HeadersCompiler = headers => {
  var validHeaders = headers.filter(h => !!h);

  function getResult(modifyConfigAtBreakpoint) {
    var result = {
      totalHeight: {},
      diffHeight: {}
    };
    var prevHidden = Array(validHeaders.length).fill(false); // keep track of hidden in previous breakpoint

    var _loop = function _loop(_bp) {
      var configs = [];
      var shouldCalculate = false;
      shouldCalculate = prevHidden.some(bool => !!bool);
      validHeaders.forEach(builder => {
        if (builder.config[_bp]) {
          shouldCalculate = true;
        }
      });

      if (shouldCalculate) {
        validHeaders.forEach((builder, index) => {
          var breakpointConfig = pickNearestBreakpoint(builder.config, _bp);

          if (builder.isHidden(_bp)) {
            prevHidden[index] = true;

            if (breakpointConfig) {
              configs.push(_objectSpread(_objectSpread({}, breakpointConfig), {}, {
                height: 0
              }));
            }
          } else {
            if (prevHidden[index]) {
              prevHidden[index] = false;
            }

            if (breakpointConfig) {
              configs.push(modifyConfigAtBreakpoint ? modifyConfigAtBreakpoint(_bp, builder, breakpointConfig) : breakpointConfig);
            }
          }
        });
      }

      if (configs.length) {
        var {
          totalHeight,
          diffHeight
        } = StackedHeaders(configs);

        if (pickNearestBreakpoint(result.totalHeight, _bp) !== totalHeight) {
          result.totalHeight[_bp] = totalHeight;
        }

        if (pickNearestBreakpoint(result.diffHeight, _bp) !== diffHeight) {
          result.diffHeight[_bp] = diffHeight;
        }
      }
    };

    for (var _bp of BREAKPOINT_KEYS) {
      _loop(_bp);
    }

    return result;
  }

  return {
    getClippedHeight(sidebarId) {
      // for EdgeSidebarOffset
      return getResult((bp, builder, config) => {
        return _objectSpread(_objectSpread({}, config), !builder.isClipped(sidebarId, bp) && {
          height: 0
        });
      });
    },

    getAllHeight() {
      // for InsetSidebarOffset
      return getResult();
    }

  };
};