function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { DEFAULT_THEME, LEFT_EDGE_SIDEBAR_ID, RIGHT_EDGE_SIDEBAR_ID } from "../utils/constant";
import { pickNearestBreakpoint } from "../utils/pickNearestBreakpoint";
import { combineBreakpoints } from "../utils/combineBreakpoints";
import { createWidthInterface } from "../Width/WidthModel";
import { toValidCssValue } from "../utils/toValidCssValue";
import { ResponsiveBuilder } from "../shared/ResponsiveBuilder";
export class HeaderBuilder extends ResponsiveBuilder {
  constructor(params) {
    super(params);

    _defineProperty(this, "effectedBy", {});
  }

  isClipped(clippableId, breakpoint) {
    var headerBreakpointConfig = pickNearestBreakpoint(this.config, breakpoint);

    if (typeof (headerBreakpointConfig === null || headerBreakpointConfig === void 0 ? void 0 : headerBreakpointConfig.clipped) === "boolean" && headerBreakpointConfig.clipped) {
      return true;
    }

    return typeof (headerBreakpointConfig === null || headerBreakpointConfig === void 0 ? void 0 : headerBreakpointConfig.clipped) === "object" && (headerBreakpointConfig === null || headerBreakpointConfig === void 0 ? void 0 : headerBreakpointConfig.clipped[clippableId]);
  }

  isAboveSomeEdgeSidebar(breakpoint) {
    var headerBreakpointConfig = pickNearestBreakpoint(this.config, breakpoint);
    if (!headerBreakpointConfig) return false;
    var {
      clipped
    } = headerBreakpointConfig;

    if (typeof clipped === "boolean") {
      return clipped;
    }

    return !!(clipped !== null && clipped !== void 0 && clipped.leftEdgeSidebar) || !!(clipped !== null && clipped !== void 0 && clipped.rightEdgeSidebar);
  }

  getOffsetHeight() {
    return this.generateSxWithHidden({
      // https://github.com/mui-org/material-ui/blob/next/packages/material-ui-system/src/sizing.js#L5
      hiddenValue: "0px",
      // don't use 0 as number because it will become 0%
      assignValue: breakpointConfig => breakpointConfig.position === "fixed" ? breakpointConfig.height : "0px"
    });
  }

  getSxHeight() {
    var result = this.generateSxWithHidden({
      assignValue: breakpointConfig => breakpointConfig.height,
      // https://github.com/mui-org/material-ui/blob/next/packages/material-ui-system/src/sizing.js#L5
      hiddenValue: "0px" // don't use 0 as number because it will become 0%

    });
    return _objectSpread({}, Object.keys(result).length && {
      height: result
    });
  }

  getSxMarginHorizontal() {
    var marginLeft = {};
    var {
      leftEdgeSidebar,
      rightEdgeSidebar
    } = this.effectedBy;

    if (leftEdgeSidebar) {
      var occupiedSpace = leftEdgeSidebar === null || leftEdgeSidebar === void 0 ? void 0 : leftEdgeSidebar.getOccupiedSpace();
      var breakpoints = this.mergeBreakpoints(occupiedSpace);

      for (var bp of breakpoints) {
        marginLeft[bp] = this.isClipped(LEFT_EDGE_SIDEBAR_ID, bp) ? "0px" : toValidCssValue(pickNearestBreakpoint(occupiedSpace, bp));
      }
    }

    var marginRight = {};

    if (rightEdgeSidebar) {
      var _occupiedSpace = rightEdgeSidebar === null || rightEdgeSidebar === void 0 ? void 0 : rightEdgeSidebar.getOccupiedSpace();

      var _breakpoints = this.mergeBreakpoints(_occupiedSpace);

      for (var _bp of _breakpoints) {
        marginRight[_bp] = this.isClipped(RIGHT_EDGE_SIDEBAR_ID, _bp) ? "0px" : toValidCssValue(pickNearestBreakpoint(_occupiedSpace, _bp));
      }
    }

    return _objectSpread(_objectSpread({}, Object.keys(marginLeft).length && {
      marginLeft
    }), Object.keys(marginRight).length && {
      marginRight
    });
  }

  getSxWidth() {
    var _leftEdgeSidebar$getO, _rightEdgeSidebar$get;

    var result = {};
    var {
      leftEdgeSidebar,
      rightEdgeSidebar
    } = this.effectedBy;
    var leftOccupiedSpace = (_leftEdgeSidebar$getO = leftEdgeSidebar === null || leftEdgeSidebar === void 0 ? void 0 : leftEdgeSidebar.getOccupiedSpace()) !== null && _leftEdgeSidebar$getO !== void 0 ? _leftEdgeSidebar$getO : {};
    var rightOccupiedSpace = (_rightEdgeSidebar$get = rightEdgeSidebar === null || rightEdgeSidebar === void 0 ? void 0 : rightEdgeSidebar.getOccupiedSpace()) !== null && _rightEdgeSidebar$get !== void 0 ? _rightEdgeSidebar$get : {};
    var breakpoints = this.mergeBreakpoints(combineBreakpoints(leftOccupiedSpace, rightOccupiedSpace));

    for (var key of breakpoints) {
      var bp = key;
      var effectLeft = createWidthInterface(0);

      if (leftEdgeSidebar) {
        if (!this.isClipped(LEFT_EDGE_SIDEBAR_ID, bp)) {
          effectLeft = createWidthInterface(leftEdgeSidebar.isFlexiblePersistent(bp, "header") ? 0 : pickNearestBreakpoint(leftOccupiedSpace, bp));
        }
      }

      var effectRight = createWidthInterface(0);

      if (rightEdgeSidebar) {
        if (!this.isClipped(RIGHT_EDGE_SIDEBAR_ID, bp)) {
          effectRight = createWidthInterface(rightEdgeSidebar.isFlexiblePersistent(bp, "header") ? 0 : pickNearestBreakpoint(rightOccupiedSpace, bp));
        }
      }

      result[bp] = effectLeft.combine(effectRight).getStyle().width;
    }

    return _objectSpread({}, Object.keys(result).length && {
      width: result
    });
  }

  getSxZIndex() {
    var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_THEME;
    var result = this.generateSx((config, bp) => {
      var _config$layer;

      return this.isAboveSomeEdgeSidebar(bp) ? theme.zIndex.drawer + 10 + ((_config$layer = config.layer) !== null && _config$layer !== void 0 ? _config$layer : 0) : theme.zIndex.appBar;
    }, theme.zIndex.appBar);
    return _objectSpread({}, Object.keys(result).length && {
      zIndex: result
    });
  }

  getSxProps() {
    var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_THEME;
    var sxTop = this.generateSx(config => config.top, 0);
    var sxDisplay = this.getSxDisplay("flex");
    var displayKeys = Object.keys(sxDisplay);
    var shouldAttachDisplay = displayKeys.length > 1 || displayKeys.length === 1 && displayKeys[0] !== "xs";
    return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
      position: this.generateSx(config => config.position)
    }, Object.keys(sxTop).length && {
      top: sxTop
    }), shouldAttachDisplay && {
      display: sxDisplay
    }), this.getSxHeight()), this.getSxWidth()), this.getSxMarginHorizontal()), this.getSxZIndex(theme));
  }

}