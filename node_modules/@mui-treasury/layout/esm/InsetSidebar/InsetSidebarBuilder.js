function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { subtractCalc } from "../utils/calc";
import { pickNearestBreakpoint } from "../utils/pickNearestBreakpoint";
import { ResponsiveBuilder } from "../shared/ResponsiveBuilder";
import { flattenLoose, flattenStrict } from "../utils/flattenResponsive";
import { toValidCssValue } from "../utils/toValidCssValue";
export class InsetSidebarBuilder extends ResponsiveBuilder {
  constructor(params) {
    super(params);

    _defineProperty(this, "effectedBy", {});
  }

  getFixedArea() {
    var modifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return flattenLoose(this.generateSx((config, bp) => config.position === "fixed" ? "".concat(modifier * 9999, "px") : bp === "xs" ? undefined : "initial"));
  }

  getSxBody() {
    var anchor = this.anchor;
    var height = {};
    var {
      header
    } = this.effectedBy;

    if (header) {
      var {
        height: responsiveHeight
      } = header.getSxHeight();
      var breakpoints = this.mergeBreakpoints(responsiveHeight !== null && responsiveHeight !== void 0 ? responsiveHeight : []);

      for (var bp of breakpoints) {
        var insetConfig = pickNearestBreakpoint(this.config, bp);

        if ((insetConfig === null || insetConfig === void 0 ? void 0 : insetConfig.position) === "absolute") {
          var headerHeight = pickNearestBreakpoint(responsiveHeight, bp);
          height[bp] = headerHeight === 0 || headerHeight === "0px" ? "100vh" : subtractCalc("100vh", headerHeight);
        }

        if ((insetConfig === null || insetConfig === void 0 ? void 0 : insetConfig.position) === "fixed") height[bp] = "100%";
        if ((insetConfig === null || insetConfig === void 0 ? void 0 : insetConfig.position) === "sticky") height[bp] = "initial";
      }
    }

    return _objectSpread(_objectSpread({
      height: flattenLoose(height),
      width: flattenLoose(this.generateSx(config => config.position === "fixed" ? "initial" : "100%")),
      position: flattenLoose(this.generateSx(config => config.position)),
      top: flattenLoose(this.generateSx(config => {
        var _config$top;

        return (_config$top = config.top) !== null && _config$top !== void 0 ? _config$top : 0;
      }))
    }, anchor === "left" && {
      marginLeft: this.getFixedArea(-1),
      paddingLeft: this.getFixedArea()
    }), anchor === "right" && {
      marginRight: this.getFixedArea(-1),
      paddingRight: this.getFixedArea()
    });
  }

  getSxRoot() {
    return {
      display: flattenStrict(this.getSxDisplay("block")),
      width: flattenLoose(this.generateSx(config => toValidCssValue(config.width)))
    };
  }

  getOccupiedSpace() {
    return flattenStrict(this.generateSxWithHidden({
      assignValue: config => toValidCssValue(config.width),
      hiddenValue: "0px",
      strict: true
    }));
  }

}